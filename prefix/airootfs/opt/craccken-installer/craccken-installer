#!/bin/env bash

# ISO Specific Variables, READ CAREFULLY FOR YOUR DISTRO
ISO_HOST="Craccken"             # ISO Host Name
ISO_USER="user"           		# Live user account
VERSION="Craccken Installer"    # Installer Name / Version

# This should not need to be changed
ANSWER="/tmp/craccken-installer_answer" # Create a temporary file to store menu selections

# Installation
KEYMAP="us"          					# Virtual console keymap, Default is "us"
XKBMAP="us"      	    				# X11 keyboard layout, Default is "us"

# Architecture
ARCHI=$(uname -m)     					# Display whether 32 or 64 bit system
ROOT_PART=""          					# ROOT partition
UEFI_PART=""							# UEFI partition
UEFI_MOUNT=""         					# UEFI mountpoint
INST_DEV=""           					# Device where system has been installed
HIGHLIGHT=0           					# Highlight items for Main Menu
HIGHLIGHT_SUB=0	    					# Highlight items for submenus
SUB_MENU=""           					# Submenu to be highlighted

# Logical Volume Management
LVM=0                   				# Logical Volume Management Detected?
LVM_SEP_BOOT=0          				# 1 = Seperate /boot, 2 = seperate /boot & LVM
LVM_VG=""               				# Name of volume group to create or use
LVM_VG_MB=0             				# MB remaining of VG
LVM_LV_NAME=""          				# Name of LV to create or use
LV_SIZE_INVALID=0       				# Is LVM LV size entered valid?
VG_SIZE_TYPE=""         				# Is VG in Gigabytes or Megabytes?

# LUKS
LUKS=0                  				# Luks Detected?
LUKS_DEV=""								# If encrypted, partition
LUKS_NAME=""							# Name given to encrypted partition
LUKS_UUID=""							# UUID used for comparison purposes
LUKS_OPT=""								# Default or user-defined?

# Installation
MOUNTPOINT="/mnt"       				# Installation
AIROOTIMG=""                			# Root image to install
BYPASS="$MOUNTPOINT/bypass/" 			# Root image mountpoint
BTRFS=0                     			# BTRFS used? "1" = btrfs alone, "2" = btrfs + subvolume(s)
MOUNT_OPTS="/tmp/.mnt_opts" 			# Filesystem Mount options
FS_OPTS=""								# FS mount options available
CHK_NUM=16								# Used for FS mount options checklist length

{ # Create a function
    if [[ "$(cat /sys/class/dmi/id/sys_vendor)" == 'Apple Inc.' ]] || [[ "$(cat /sys/class/dmi/id/sys_vendor)" == 'Apple Computer, Inc.' ]]; then # Check if system is made by apple
        modprobe -r -q efivars # Remove a module from the kernel with quiet mode
    else
        modprobe -q efivarfs # Load a module into the kernel with quiet mode
    fi # End if-else statement
    if [[ -d /sys/firmware/efi/ ]]; then # Check if system is UEFI or BIOS
        [[ -z $(mount | grep /sys/firmware/efi/efivars) ]] && mount -t efivarfs efivarfs /sys/firmware/efi/efivars # Mount efivarfs if it is not already mounted
        SYSTEM="UEFI" # Set variable SYSTEM to UEFI
    else
        SYSTEM="BIOS" # Set variable SYSTEM to BIOS
    fi # End if-else statement
    BACKTITLE="$VERSION - $SYSTEM ($ARCHI)"
}

run_command_in_mountpoint(){ # Create a function 
    arch-chroot $MOUNTPOINT /bin/bash -c "${1}" # Run shell command to mountpoint
}  

check_for_error(){ # Create a function 
    if [[ $? -eq 1 ]] && [[ $(cat /tmp/.errlog | grep -i "error") != "" ]]; then # If there is an error and then
        dialog --backtitle "$BACKTITLE" --title " $_ErrTitle " --msgbox "$(cat /tmp/.errlog)" 0 0 # Display error-msg from log. 
        echo "" > /tmp/.errlog && main_menu # Clear the log && go back to the main menu (no point in continuing).
    fi # End if-else statement
}

check_mount(){ # Create a function
    [[ -z $(lsblk -o MOUNTPOINT | grep ${MOUNTPOINT}) ]] && dialog --backtitle "$BACKTITLE" --title " $_ErrTitle " --msgbox "$_ErrNoMount" 0 0 && main_menu # Ensure that a partition is mounted && Call main_menu function 
}

check_base(){ # Create a function
    [[ ! -e ${MOUNTPOINT}/etc ]] && dialog --backtitle "$BACKTITLE" --title " $_ErrTitle " --msgbox "$_ErrNoBase" 0 0 && main_menu # Ensure that base of craccken has been installed
}

show_devices(){ # Create a function
    lsblk -o NAME,MODEL,TYPE,FSTYPE,SIZE,MOUNTPOINT | grep "disk\|part\|lvm\|crypt\|NAME\|MODEL\|TYPE\|FSTYPE\|SIZE\|MOUNTPOINT" 1>/tmp/.devlist # Show devices / partitions.
    dialog --backtitle "$BACKTITLE" --title " $_DevShowOpt " --textbox /tmp/.devlist 0 0
}

set_xkbmap(){ # Create a function
    local XKBMAP_LIST
	keymaps_xkb=("af al am at az ba bd be bg br bt bw by ca cd ch cm cn cz de dk ee es et eu fi fo fr gb ge gh gn gr hr hu ie il in iq ir is it jp ke kg kh kr kz la lk lt lv ma md me mk ml mm mn mt mv ng nl no np pc ph pk pl pt ro rs ru se si sk sn sy tg th tj tm tr tw tz ua us uz vn za")
	for i in $keymaps_xkb; do
        XKBMAP_LIST="${XKBMAP_LIST} ${i} -"
    done
    dialog --backtitle "$BACKTITLE" --title " Set Desktop Keyboard Layout " --scrollbar --cursor-off-label --menu "$_XkbmapBody" 0 0 16 \
        ${XKBMAP_LIST} 2>${ANSWER} || prep_menu
    XKBMAP=$(read_answer)
    echo -e "Section "\"InputClass"\"\nIdentifier "\"system-keyboard"\"\nMatchIsKeyboard "\"on"\"\nOption "\"XkbLayout"\" "\"${XKBMAP}"\"\nEndSection" > /tmp/01-keyboard-layout.conf
	setxkbmap $XKBMAP # Set keymap for X11
}

set_locale(){ # Create a function
    local SET_LOCALE_OPT # Create local variable
    for option in $(cat /etc/locale.gen | grep -v "#  " | sed 's/#//g' | sed 's/ UTF-8//g' | grep .UTF-8); do # Create for-loop with locale array in /etc/locale.gen file
        SET_LOCALE_OPT="${SET_LOCALE_OPT} ${option} -"
    done
    dialog --backtitle "$BACKTITLE" --title " $_ConfBseSysLoc " --menu "$_localeBody" 0 0 12 ${SET_LOCALE_OPT} 2>${ANSWER} || config_base_menu 
    echo "LANG=\"$(read_answer)\"" > ${MOUNTPOINT}/etc/locale.conf
    sed -i "s/#$(read_answer)/$(read_answer)/" ${MOUNTPOINT}/etc/locale.gen
    run_command_in_mountpoint "locale-gen" 1>/dev/null
}

set_timezone(){ # Create a function
    local ZONE SUBZONE
    for i in $(cat /usr/share/zoneinfo/zone.tab | awk '{print $3}' | grep "/" | sed "s/\/.*//g" | sort -ud); do
        ZONE="$ZONE ${i} -"
    done
    dialog --backtitle "$BACKTITLE" --title " $_ConfBseTimeHC " --menu "$_TimeZBody" 0 0 10 ${ZONE} 2>${ANSWER} || config_base_menu
    ZONE=$(read_answer) 
    
    for i in $(cat /usr/share/zoneinfo/zone.tab | awk '{print $3}' | grep "${ZONE}/" | sed "s/${ZONE}\///g" | sort -ud); do
        SUBZONE="$SUBZONE ${i} -"
    done
    dialog --backtitle "$BACKTITLE" --title " $_ConfBseTimeHC " --menu "$_TimeSubZBody" 0 0 11 ${SUBZONE} 2>${ANSWER} || config_base_menu
    SUBZONE=$(read_answer) 

    dialog --backtitle "$BACKTITLE" --title " $_ConfBseTimeHC " --yesno "$_TimeZQ ${ZONE}/${SUBZONE}?" 0 0 
    if [[ $? -eq 0 ]]; then
        run_command_in_mountpoint "ln -sf /usr/share/zoneinfo/${ZONE}/${SUBZONE} /etc/localtime" # Set Zone and Sub-Zone
    else
        config_base_menu
    fi # End if-else statement
}

set_hw_clock(){
    # dialog --backtitle "$BACKTITLE" --title " $_ConfBseTimeHC " --menu "$_HwCBody" 0 0 2 "utc" "-" "localtime" "-" 2>${ANSWER}	
    local time_options="$(echo -e "# UTC is the universal time standard, and is recommended unless dual-booting with Windows.\n# Please type 'utc' or 'localtime' below this comment" | vipe)"
    [[ -n "${time_options}" ]] && run_command_in_mountpoint "hwclock --systohc --${time_options}" # Check if answer not empty then run command to set hardware clock
}

generate_fstab(){ # Generate the installed system's FSTAB
    [[ $SYSTEM == "BIOS" ]] && genfstab -U -p ${MOUNTPOINT} > ${MOUNTPOINT}/etc/fstab || genfstab -t PARTUUID -p ${MOUNTPOINT} > ${MOUNTPOINT}/etc/fstab
    [[ -f ${MOUNTPOINT}/swapfile ]] && sed -i "s/\\${MOUNTPOINT}//" ${MOUNTPOINT}/etc/fstab
}

set_hostname(){ # Set the installed system's hostname
    dialog --backtitle "$BACKTITLE" --title " $_ConfBseHost " --inputbox "$_HostNameBody" 0 0 "craccken" 2>${ANSWER} || config_base_menu
    echo "$(read_answer)" > ${MOUNTPOINT}/etc/hostname 2>/tmp/.errlog
    echo -e "#<ip-address>\t<hostname.domain.org>\t<hostname>\n127.0.0.1\tlocalhost.localdomain\tlocalhost\t$(read_answer)\n::1\tlocalhost.localdomain\tlocalhost\t$(read_answer)" > ${MOUNTPOINT}/etc/hosts 
}

create_new_user(){ # Create new user(s) for installed system. First user is created by renaming the live account. All others are brand new.
	dialog --backtitle "$BACKTITLE" --title " $_NUsrTitle " --inputbox "$_NUsrBody" 0 0 "" 2>${ANSWER} || config_base_menu
	USER=$(read_answer)
	while [[ ${#USER} -eq 0 ]] || [[ $USER =~ \ |\' ]] || [[ $USER =~ [^a-z0-9\ ] ]]; do # Loop while user name is blank, has spaces, or has capital letters in it.
		dialog --backtitle "$BACKTITLE" --title " $_NUsrTitle " --inputbox "$_NUsrErrBody" 0 0 "" 2>${ANSWER} || config_base_menu
		USER=$(read_answer)
	done # End while-loop statement

	# Enter password. This step will only be reached where the loop has been skipped or broken.
	dialog --backtitle "$BACKTITLE" --title " $_ConfUsrNew " --clear --insecure --passwordbox "$_PassNUsrBody $USER\n\n" 0 0 2> ${ANSWER} || config_base_menu
	PASSWD=$(read_answer) 
	dialog --backtitle "$BACKTITLE" --title " $_ConfUsrNew " --clear --insecure --passwordbox "$_PassReEntBody" 0 0 2> ${ANSWER} || config_base_menu
	PASSWD2=$(read_answer) 
	while [[ ! "$PASSWD" == "$PASSWD2" ]]; do # loop while passwords entered do not match.
		dialog --backtitle "$BACKTITLE" --title " $_ErrTitle " --msgbox "$_PassErrBody" 0 0
		dialog --backtitle "$BACKTITLE" --title " $_ConfUsrNew " --clear --insecure --passwordbox "$_PassNUsrBody $USER\n\n" 0 0 2> ${ANSWER} || config_base_menu
		PASSWD=$(read_answer) 
		dialog --backtitle "$BACKTITLE" --title " $_ConfUsrNew " --clear --insecure --passwordbox "$_PassReEntBody" 0 0 2> ${ANSWER} || config_base_menu
		PASSWD2=$(read_answer) 
	done
    if [[ -e ${MOUNTPOINT}/home/$ISO_USER ]]; then # If the first (or only) user account, then change the live account
        run_command_in_mountpoint "echo '${ISO_USER}:${PASSWD}' | chpasswd" >/dev/null 2>>/tmp/.errlog
        sed -i "s/$ISO_USER/$USER/g" ${MOUNTPOINT}/home/$ISO_USER/.gtkrc-2.0 2>/tmp/.errlog # Distro-specific configuration for entered username

        # Convert live account to entered username - group, password, folder, and ownership
        sed -i "s/$ISO_USER/$USER/g" ${MOUNTPOINT}/etc/group 2>>/tmp/.errlog
        sed -i "s/$ISO_USER/$USER/g" ${MOUNTPOINT}/etc/gshadow 2>>/tmp/.errlog
        sed -i "s/$ISO_USER/$USER/g" ${MOUNTPOINT}/etc/passwd 2>>/tmp/.errlog
        sed -i "s/$ISO_USER/$USER/g" ${MOUNTPOINT}/etc/shadow 2>>/tmp/.errlog
        mv ${MOUNTPOINT}/home/$ISO_USER ${MOUNTPOINT}/home/$USER 2>>/tmp/.errlog
        chown -R $USER:users ${MOUNTPOINT}/home/$USER 2>>/tmp/.errlog
        
        # Change sudoers file to require passwords for sudo commands
        # sed -i '/%wheel ALL=(ALL) ALL/s/^#//' ${MOUNTPOINT}/etc/sudoers 2>>/tmp/.errlog
        # sed -i '/%wheel ALL=(ALL) ALL NOPASSWD: ALL/s/#%wheel ALL=(ALL) ALL NOPASSWD: ALL//' ${MOUNTPOINT}/etc/sudoers 2>>/tmp/.errlog
        # check_for_error
	else
        # If the live account has already been changed, create a new user account
        run_command_in_mountpoint "useradd ${USER} -m -g users -G wheel,storage,power,network,video,audio,lp -s /bin/zsh" 2>/tmp/.errlog   
        run_command_in_mountpoint "echo '${USER}:${PASSWD}' | chpasswd" >/dev/null 2>>/tmp/.errlog  
        # run_command_in_mountpoint "passwd ${USER}" < /tmp/.passwd >/dev/null 2>>/tmp/.errlog  

        # Set up basic configuration files and ownership for new account
        run_command_in_mountpoint "cp -R /etc/skel /home/${USER}" 2>>/tmp/.errlog
        run_command_in_mountpoint "chown -R ${USER}:users /home/${USER}" 2>>/tmp/.errlog

        # Update gtk user directories bookmarks
        run_command_in_mountpoint "rm -f /home/${USER}/.config/gtk-3.0/bookmarks" 2>>/tmp/.errlog
        run_command_in_mountpoint "runuser -l ${USER} -c 'xdg-user-dirs-update'" 2>>/tmp/.errlog
        run_command_in_mountpoint "runuser -l ${USER} -c 'xdg-user-dirs-gtk-update'" 2>>/tmp/.errlog
        check_for_error
    fi

    set_root_password(){ # Create a subfunction
        dialog --backtitle "$BACKTITLE" --title " $_ConfUsrRoot " --clear --insecure --passwordbox "$_PassRtBody" 0 0 2> ${ANSWER} || config_base_menu
        local ROOT_PASSWD=$(read_answer)
        dialog --backtitle "$BACKTITLE" --title " $_ConfUsrRoot " --clear --insecure --passwordbox "$_PassReEntBody" 0 0 2> ${ANSWER} || config_base_menu
        local REPEAT_ROOT_PASSWD=$(read_answer)

        if [[ "$ROOT_PASSWD" == "$REPEAT_ROOT_PASSWD" ]]; then
            run_command_in_mountpoint "echo 'root:${ROOT_PASSWD}' | chpasswd" >/dev/null 2>/tmp/.errlog # Set the installed system's root password
        else
            dialog --backtitle "$BACKTITLE" --title " $_ErrTitle " --msgbox "$_PassErrBody" 0 0
            set_root_password # Call set_root_password function
        fi # End if-else statement
    }
    set_root_password
}

run_mkinitcpio(){ # Create a function
	# If LVM and/or LUKS used, add the relevant hook(s)
	([[ $LVM -eq 1 ]] && [[ $LUKS -eq 0 ]]) && sed -i 's/block filesystems/block lvm2 filesystems/g' ${MOUNTPOINT}/etc/mkinitcpio.conf 2>/tmp/.errlog
    ([[ $LVM -eq 1 ]] && [[ $LUKS -eq 1 ]]) && sed -i 's/block filesystems/block encrypt lvm2 filesystems/g' ${MOUNTPOINT}/etc/mkinitcpio.conf 2>/tmp/.errlog && sed -i 's/#GRUB_ENABLE_CRYPTODISK=.*/GRUB_ENABLE_CRYPTODISK=y/g' ${MOUNTPOINT}/etc/default/grub 2>/tmp/.errlog
    ([[ $LVM -eq 0 ]] && [[ $LUKS -eq 1 ]]) && sed -i 's/block filesystems/block encrypt filesystems/g' ${MOUNTPOINT}/etc/mkinitcpio.conf 2>/tmp/.errlog && sed -i 's/#GRUB_ENABLE_CRYPTODISK=.*/GRUB_ENABLE_CRYPTODISK=y/g' ${MOUNTPOINT}/etc/default/grub 2>/tmp/.errlog
    check_for_error
    sed -i 's/archiso archiso_loop_mnt archiso_kms/autodetect/g' ${MOUNTPOINT}/etc/mkinitcpio.conf 2>/tmp/.errlog # Remove archiso hooks from install
    sed -i 's/keyboard/keyboard fsck/g' ${MOUNTPOINT}/etc/mkinitcpio.conf 2>/tmp/.errlog # Add fsck hook
    run_command_in_mountpoint "mkinitcpio -p linux" 2>>/tmp/.errlog
	check_for_error
}

umount_partitions(){
    swapoff --all
    local MOUNTED=$(mount | grep "${MOUNTPOINT}" | awk '{print $3}' | sort -r)
    for mounted_partition in ${MOUNTED[@]}; do
        umount $mounted_partition
    done # End for-loop statement
}

confirm_mount(){ # Revised to deal with partion sizes now being displayed to the user
    if [[ $(mount | grep $1) ]]; then   
        dialog --backtitle "$BACKTITLE" --title " $_MntStatusTitle " --infobox "$_MntStatusSucc" 0 0
        PARTITIONS=$(echo $PARTITIONS | sed "s~${PARTITION} [0-9]*[G-M]~~" | sed "s~${PARTITION} [0-9]*\.[0-9]*[G-M]~~" | sed s~${PARTITION}$' -'~~)
        NUMBER_PARTITIONS=$(( NUMBER_PARTITIONS - 1 ))
    else
        dialog --backtitle "$BACKTITLE" --title " $_MntStatusTitle " --infobox "$_MntStatusFail" 0 0
        prep_menu
    fi # End if-else statement
}

# This function does not assume that the formatted device is the Root installation device as 
# more than one device may be formatted. Root is set in the mount_partitions function.
select_device(){
    DEVICE=""
    devices_list=$(lsblk -lno NAME,SIZE,TYPE | grep 'disk' | awk '{print "/dev/" $1 " " $2}' | sort -u);
    for i in "${devices_list[@]}"; do
        DEVICE="${DEVICE} ${i}"
    done
    dialog --backtitle "$BACKTITLE" --title " $_DevSelTitle " --menu "$_DevSelBody" 0 0 4 ${DEVICE} 2>${ANSWER} || prep_menu
    DEVICE=$(read_answer)
}

find_partitions(){ # Finds all available partitions according to type(s) specified and generates a list of them. This also includes partitions on different devices.
	PARTITIONS=""
	NUMBER_PARTITIONS=0	
	partition_list=$(lsblk -lno NAME,SIZE,TYPE | grep $INCLUDE_PART | sed 's/part$/\/dev\//g' | sed 's/lvm$\|crypt$/\/dev\/mapper\//g' | awk '{print $3$1 " " $2}' | sort -u)
    for i in ${partition_list}; do
        PARTITIONS="${PARTITIONS} ${i}"
        NUMBER_PARTITIONS=$(( NUMBER_PARTITIONS + 1 ))
    done
    NUMBER_PARTITIONS=$(( NUMBER_PARTITIONS / 2 )) # Double-partitions will be counted due to counting sizes, so fix
	case $INCLUDE_PART in
	'part\|lvm\|crypt') # Deal with incorrect partitioning for main mounting function
		if ([[ $SYSTEM == "UEFI" ]] && [[ $NUMBER_PARTITIONS -lt 2 ]]) || ([[ $SYSTEM == "BIOS" ]] && [[ $NUMBER_PARTITIONS -eq 0 ]]); then
			dialog --backtitle "$BACKTITLE" --title " $_ErrTitle " --msgbox "$_PartErrBody" 0 0
			create_partitions
        fi ;;
	'part\|crypt') # Ensure there is at least one partition for LVM 
		if [[ $NUMBER_PARTITIONS -eq 0 ]]; then
			dialog --backtitle "$BACKTITLE" --title " $_ErrTitle " --msgbox "$_LvmPartErrBody" 0 0
			create_partitions
        fi ;;
	'part\|lvm') # Ensure there are at least two partitions for LUKS
		if [[ $NUMBER_PARTITIONS -lt 2 ]]; then
			dialog --backtitle "$BACKTITLE" --title " $_ErrTitle " --msgbox "$_LuksPartErrBody" 0 0
			create_partitions
        fi ;;
	esac
}

create_partitions(){ [[ -n "$DISPLAY" ]] && gparted "${DEVICE}" || parted "${DEVICE}"; }

select_filesystem(){
	fs_opts=""
	CHK_NUM=0
    dialog --backtitle "$BACKTITLE" --title " $_FSTitle " --menu "$_FSBody" 0 0 10 \
        "Skip" "-" \
        "ext4" "mkfs.ext4 -q" \
        "btrfs" "mkfs.btrfs -f" 2>${ANSWER}
        # "btrfs" "mkfs.btrfs -f" \
        "f2fs" "mkfs.f2fs" \
        # "reiserfs" "mkfs.reiserfs -q" \
        # "xfs" "mkfs.xfs -f" 2>${ANSWER}	
	case $(read_answer) in # Read answer from select_filesystem function
		"Skip")
            FILESYSTEM="Skip" ;;
		"btrfs")
            FILESYSTEM="mkfs.btrfs -f"	
			CHK_NUM=16; fs_opts="autodefrag compress=zlib compress=lzo compress=no compress-force=zlib compress-force=lzo discard noacl noatime nodatasum nospace_cache recovery skip_balance space_cache ssd ssd_spread"
			modprobe btrfs ;;
		"ext4")
            FILESYSTEM="mkfs.ext4 -q"
			CHK_NUM=8; fs_opts="data=journal data=writeback dealloc discard noacl noatime nobarrier nodelalloc" ;;
		"f2fs")
            FILESYSTEM="mkfs.f2fs"
			CHK_NUM=16; fs_opts="data_flush disable_roll_forward disable_ext_identify discard fastboot flush_merge inline_xattr inline_data inline_dentry no_heap noacl nobarrier noextent_cache noinline_data norecovery"
			modprobe f2fs ;;
		"reiserfs")
            FILESYSTEM="mkfs.reiserfs -q"
			CHK_NUM=5; fs_opts="acl nolog notail replayonly user_xattr" ;;
		"xfs")
            FILESYSTEM="mkfs.xfs -f"
			CHK_NUM=9; fs_opts="discard filestreams ikeep largeio noalign nobarrier norecovery noquota wsync" ;;
		*)
            prep_menu ;;
	esac
    if [[ ! $FILESYSTEM == "Skip" ]]; then
        dialog --backtitle "$BACKTITLE" --title " $_FSTitle " --yesno "\n$FILESYSTEM $PARTITION\n\n" 0 0 # Warn about formatting!
        if [[ $? -eq 0 ]]; then
            ${FILESYSTEM} ${PARTITION} >/dev/null 2>/tmp/.errlog
            check_for_error
        else
            select_filesystem
        fi
    fi
}
  
mount_partitions(){
    # This subfunction allows for special mounting options to be applied for relevant fs's.
    # Seperate subfunction for neatness.
    mount_opts() {
        FS_OPTS=""
        echo "" > ${MOUNT_OPTS}
        for i in ${fs_opts}; do
            FS_OPTS="${FS_OPTS} ${i} - off"
        done
        dialog --backtitle "$BACKTITLE" --title " $(echo $FILESYSTEM | sed "s/.*\.//g" | sed "s/-.*//g") " --checklist "$_btrfsMntBody" 0 0 $CHK_NUM \
        $FS_OPTS 2>${MOUNT_OPTS}
        
        # Now clean up the file
        sed -i 's/ /,/g' ${MOUNT_OPTS}
        sed -i '$s/,$//' ${MOUNT_OPTS}
        if [[ $(cat ${MOUNT_OPTS}) != "" ]]; then # If mount options selected then
            dialog --backtitle "$BACKTITLE" --title " $_MntStatusTitle " --yesno "\n${_btrfsMntConfBody}$(cat ${MOUNT_OPTS})\n" 10 75 # Confirm choice 
            [[ $? -eq 1 ]] && mount_opts
        fi # End if-else statement
    }

    mount_current_partition(){ # Subfunction to save repetition of code
        mkdir -p ${MOUNTPOINT}${MOUNT} 2>/tmp/.errlog # Make the mount directory
        # Get mounting options for appropriate filesystems
        [[ $fs_opts != "" ]] && mount_opts

        # Use special mounting options if selected, else standard mount
        if [[ $(cat ${MOUNT_OPTS}) != "" ]]; then
            mount -o $(cat ${MOUNT_OPTS}) ${PARTITION} ${MOUNTPOINT}${MOUNT} 2>>/tmp/.errlog
        else
            mount ${PARTITION} ${MOUNTPOINT}${MOUNT} 2>>/tmp/.errlog
        fi
        check_for_error
        confirm_mount ${MOUNTPOINT}${MOUNT}
        # Identify if mounted partition is type "crypt" (LUKS on LVM, or LUKS alone)
        if [[ $(lsblk -lno TYPE ${PARTITION} | grep "crypt") != "" ]]; then
            # cryptname for bootloader configuration either way
            LUKS=1
            LUKS_NAME=$(echo ${PARTITION} | sed "s~^/dev/mapper/~~g")

            # Check if LUKS on LVM (parent = lvm /dev/mapper/...) 
            cryptparts=$(lsblk -lno NAME,FSTYPE,TYPE | grep "lvm" | grep -i "crypto_luks" | uniq | awk '{print "/dev/mapper/"$1}')
            for i in ${cryptparts}; do
                if [[ $(lsblk -lno NAME ${i} | grep $LUKS_NAME) != "" ]]; then
                    LUKS_DEV="$LUKS_DEV cryptdevice=${i}:$LUKS_NAME"
                    LVM=1
                    break;
                fi
            done
            
            # Check if LUKS alone (parent = part /dev/...)
            cryptparts=$(lsblk -lno NAME,FSTYPE,TYPE | grep "part" | grep -i "crypto_luks" | uniq | awk '{print "/dev/"$1}')
            for i in ${cryptparts}; do
                if [[ $(lsblk -lno NAME ${i} | grep $LUKS_NAME) != "" ]]; then
                    LUKS_UUID=$(lsblk -lno UUID,TYPE,FSTYPE ${i} | grep "part" | grep -i "crypto_luks" | awk '{print $1}')
                    LUKS_DEV="$LUKS_DEV cryptdevice=UUID=$LUKS_UUID:$LUKS_NAME"
                    break;
                fi
            done
        elif [[ $(lsblk -lno TYPE ${PARTITION} | grep "lvm") != "" ]]; then # If LVM logical volume....
            LVM=1
            # First get crypt name (code above would get lv name)
            cryptparts=$(lsblk -lno NAME,TYPE,FSTYPE | grep "crypt" | grep -i "lvm2_member" | uniq | awk '{print "/dev/mapper/"$1}')
            for i in ${cryptparts}; do
                if [[ $(lsblk -lno NAME ${i} | grep $(echo $PARTITION | sed "s~^/dev/mapper/~~g")) != "" ]]; then
                    LUKS_NAME=$(echo ${i} | sed s~/dev/mapper/~~g)
                    break;
                fi
            done
            
            # Now get the device (/dev/...) for the crypt name
            cryptparts=$(lsblk -lno NAME,FSTYPE,TYPE | grep "part" | grep -i "crypto_luks" | uniq | awk '{print "/dev/"$1}')
            for i in ${cryptparts}; do
                if [[ $(lsblk -lno NAME ${i} | grep $LUKS_NAME) != "" ]]; then
                    # Create UUID for comparison
                    LUKS_UUID=$(lsblk -lno UUID,TYPE,FSTYPE ${i} | grep "part" | grep -i "crypto_luks" | awk '{print $1}')
                    if [[ $(echo $LUKS_DEV | grep $LUKS_UUID) == "" ]]; then # Check if not already added as a LUKS DEVICE (i.e. multiple LVs on one crypt). If not, add.
                        LUKS_DEV="$LUKS_DEV cryptdevice=UUID=$LUKS_UUID:$LUKS_NAME"
                        LUKS=1
                    fi
                    break;
                fi
            done
        fi
    }

    make_swap(){ # Seperate function due to ability to cancel
        dialog --backtitle "$BACKTITLE" --title " $_PrepMntPart " --menu "$_SelSwpBody" 0 0 7 "$_SelSwpNone" $"-" "$_SelSwpFile" $"-" ${PARTITIONS} 2>${ANSWER} || prep_menu  # Ask user to select partition or create swapfile
        if [[ $(read_answer) != "$_SelSwpNone" ]]; then    
            PARTITION=$(read_answer)
            if [[ $PARTITION == "$_SelSwpFile" ]]; then
                total_memory=$(grep MemTotal /proc/meminfo | awk '{print $2/1024}' | sed 's/\..*//')
                dialog --backtitle "$BACKTITLE" --title " $_SelSwpFile " --inputbox "\nM = MB, G = GB\n" 9 30 "${total_memory}M" 2>${ANSWER} || make_swap
                m_or_g=$(read_answer)
                while [[ $(echo ${m_or_g: -1} | grep "M\|G") == "" ]]; do
                    dialog --backtitle "$BACKTITLE" --title " $_SelSwpFile " --msgbox "\n$_SelSwpFile $_ErrTitle: M = MB, G = GB\n\n" 0 0
                    dialog --backtitle "$BACKTITLE" --title " $_SelSwpFile " --inputbox "\nM = MB, G = GB\n" 9 30 "${total_memory}M" 2>${ANSWER} || make_swap
                    m_or_g=$(read_answer)
                done

                fallocate -l ${m_or_g} ${MOUNTPOINT}/swapfile 2>/tmp/.errlog
                chmod 600 ${MOUNTPOINT}/swapfile 2>>/tmp/.errlog
                mkswap ${MOUNTPOINT}/swapfile 2>>/tmp/.errlog
                swapon ${MOUNTPOINT}/swapfile 2>>/tmp/.errlog
                check_for_error
            else # Swap Partition
                if [[ $(lsblk -o FSTYPE "${PARTITION}" | grep -i "swap") != "swap" ]]; then
                    dialog --backtitle "$BACKTITLE" --title " $_PrepMntPart " --yesno "\nmkswap ${PARTITION}\n\n" 0 0 # Warn user if creating a new swap
                    [[ $? -eq 0 ]] && mkswap "${PARTITION}" >/dev/null 2>/tmp/.errlog || mount_partitions
                fi
                swapon  ${PARTITION} >/dev/null 2>>/tmp/.errlog # Whether existing to newly created, activate swap
                check_for_error
                # Since a partition was used, remove that partition from the list
                PARTITIONS=$(echo $PARTITIONS | sed "s~${PARTITION} [0-9]*[G-M]~~" | sed "s~${PARTITION} [0-9]*\.[0-9]*[G-M]~~" | sed s~${PARTITION}$' -'~~)
                NUMBER_PARTITIONS=$(( NUMBER_PARTITIONS - 1 ))
            fi
        fi
    }
    #          ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
    #          ┃                        MOUNTING FUNCTION BEGINS HERE                         ┃
    #          ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
	# prep variables
	MOUNT=""
	LUKS_NAME=""
	LUKS_DEV=""
	LUKS_UUID=""
	LUKS=0
	LVM=0
	dialog --backtitle "$BACKTITLE" --title " $_PrepMntPart " --msgbox "$_WarnMount1 'Skip' $_WarnMount2" 0 0 # Warn users that they CAN mount partitions without formatting them!
    lvm_detect # LVM Detection. If detected, activate.

	# Ensure partitions are unmounted (i.e. where mounted previously), and then list available partitions
	INCLUDE_PART='part\|lvm\|crypt'
    umount_partitions
	find_partitions
	
	# Identify and mount root
	dialog --backtitle "$BACKTITLE" --title " $_PrepMntPart " --menu "$_SelRootBody" 0 0 7 ${PARTITIONS} 2>${ANSWER} || prep_menu
	PARTITION=$(read_answer)
    ROOT_PART=${PARTITION}
   	
	select_filesystem # Format with FS (or skip)
	mount_current_partition # Make the directory and mount. Also identify LUKS and/or LVM
	make_swap # Identify and create swap, if applicable
    if [[ $SYSTEM == "UEFI" ]]; then # Extra Step for VFAT UEFI Partition. This cannot be in an LVM container.
        dialog --backtitle "$BACKTITLE" --title " $_PrepMntPart " --menu "$_SelUefiBody" 0 0 7 ${PARTITIONS} 2>${ANSWER} || prep_menu  
        PARTITION=$(read_answer)
        UEFI_PART=${PARTITION}
        if [[ $(fsck -N $PARTITION | grep fat) ]]; then # If it is already a fat/vfat partition and then
            # DANGEROUS FUNCTION
            # dialog --backtitle "$BACKTITLE" --title " $_PrepMntPart " --yesno "$_FormUefiBody $PARTITION $_FormUefiBody2" 0 0 && mkfs.vfat -F32 ${PARTITION} >/dev/null 2>/tmp/.errlog
        else 
            mkfs.vfat -F32 ${PARTITION} >/dev/null 2>/tmp/.errlog
        fi
        check_for_error
             
        dialog --backtitle "$BACKTITLE" --title " $_PrepMntPart " --menu "$_MntUefiBody"  0 0 2 \
            "/boot" "systemd-boot"\
            "/boot/efi" "-" 2>${ANSWER} # Inform users of the mountpoint options and consequences       
        [[ $(read_answer) != "" ]] && UEFI_MOUNT=$(read_answer) || prep_menu
        mkdir -p ${MOUNTPOINT}${UEFI_MOUNT}
        mount ${PARTITION} ${MOUNTPOINT}${UEFI_MOUNT}
        confirm_mount ${MOUNTPOINT}${UEFI_MOUNT}           
    fi
    
    # All other partitions
	while [[ $NUMBER_PARTITIONS > 0 ]]; do 
		dialog --backtitle "$BACKTITLE" --title " $_PrepMntPart " --menu "$_ExtPartBody" 0 0 7 "$_Done" $"-" ${PARTITIONS} 2>${ANSWER} || prep_menu 
		PARTITION=$(read_answer)
		if [[ $PARTITION == $_Done ]]; then
		    break
		else
			MOUNT=""
			select_filesystem
			[[ $SYSTEM == "UEFI" ]] && MNT_EXAMPLES="/home\n/var" || MNT_EXAMPLES="/boot\n/home\n/var"
			dialog --backtitle "$BACKTITLE" --title " $_PrepMntPart $PARTITON " --inputbox "$_ExtPartBody1$MNT_EXAMPLES\n" 0 0 "/" 2>${ANSWER} || prep_menu # Ask user for mountpoint. Don't give /boot as an example for UEFI systems!
			MOUNT=$(read_answer)
			while [[ ${MOUNT:0:1} != "/" ]] || [[ ${#MOUNT} -le 1 ]] || [[ $MOUNT =~ \ |\' ]]; do # loop while the mountpoint specified is incorrect (is only '/', is blank, or has spaces). 
				dialog --backtitle "$BACKTITLE" --title " $_ErrTitle " --msgbox "$_ExtErrBody" 0 0 # Warn user about naming convention
				dialog --backtitle "$BACKTITLE" --title " $_PrepMntPart $PARTITON " --inputbox "$_ExtPartBody1$MNT_EXAMPLES\n" 0 0 "/" 2>${ANSWER} || prep_menu # Ask user for mountpoint again
				MOUNT=$(read_answer)                     
			done
			mount_current_partition # Create directory and mount.
			if [[ $MOUNT == "/boot" ]]; then # Determine if a seperate /boot is used. 0 = no seperate boot, 1=seperate non-lvm boot,  2=seperate lvm boot. For Grub configuration
			    [[ $(lsblk -lno TYPE ${PARTITION} | grep "lvm") != "" ]] && LVM_SEP_BOOT=2 || LVM_SEP_BOOT=1
			fi
		fi
	done
}	

lvm_detect(){ # LVM Detection.
    LVM_PV=$(pvs -o pv_name --noheading 2>/dev/null)
    LVM_VG=$(vgs -o vg_name --noheading 2>/dev/null)
    LVM_LV=$(lvs -o vg_name,lv_name --noheading --separator - 2>/dev/null)
    if [[ $LVM_LV != "" ]] && [[ $LVM_VG != "" ]] && [[ $LVM_PV != "" ]]; then
        dialog --backtitle "$BACKTITLE" --title " $_PrepLVM " --infobox "$_LvmDetBody" 0 0
        modprobe dm-mod 2>/tmp/.errlog
        check_for_error
        vgscan >/dev/null 2>&1
        vgchange -ay >/dev/null 2>&1
    fi
}

install_root(){
    if [[ -e /run/archiso/bootmnt/arch/x86_64/airootfs.sfs ]]; then # Change installation method depending on use of img or sfs
        AIROOTIMG="/run/archiso/bootmnt/arch/x86_64/airootfs.sfs"
        mkdir -p ${BYPASS} 2>/tmp/.errlog
	    mount ${AIROOTIMG} ${BYPASS} 2>>/tmp/.errlog
        counter=$(find ${BYPASS} | wc -l)
        rsync -av --no-i-r ${BYPASS} ${MOUNTPOINT}/ 2>/tmp/.errlog | pv -len --size "${counter}" --interval 1.0 2>&1 >/dev/null | dialog --backtitle "$BACKTITLE" --title "$VERSION - $SYSTEM ($ARCHI)" --gauge "\n" 10 75
	    umount -l ${BYPASS}
    else
        AIROOTIMG="/run/archiso/airootfs/"
        counter=$(find /run/archiso/airootfs/ | wc -l) # set the counter for pv data
	    # give rsync a progress bar as we install using pv and dialog
        rsync -av --no-i-r ${AIROOTIMG} ${MOUNTPOINT}/ 2>/tmp/.errlog | pv -len --size "${counter}" --interval 1.0 2>&1 >/dev/null | dialog --backtitle "$BACKTITLE" --title "$VERSION - $SYSTEM ($ARCHI)" --gauge "\n" 10 75
    fi
    # Keyboard config for vc and x11
    [[ -e /tmp/01-keyboard-layout.conf ]] && cp -f /tmp/01-keyboard-layout.conf ${MOUNTPOINT}/etc/X11/xorg.conf.d/$(ls ${MOUNTPOINT}/etc/X11/xorg.conf.d/ | grep "keyboard") 2>>/tmp/.errlog
    if [[ -e /run/archiso/bootmnt/arch/boot/${ARCHI}/vmlinuz-linux ]]; then # set up kernel for mkiniticpio
	    cp /run/archiso/bootmnt/arch/boot/${ARCHI}/vmlinuz-linux ${MOUNTPOINT}/boot/vmlinuz-linux
    else
        cp /usr/lib/modules/$(uname -r)/vmlinuz ${MOUNTPOINT}/boot/vmlinuz-linux
    fi
    cp /etc/pacman.d/mirrorlist ${MOUNTPOINT}/etc/pacman.d/mirrorlist 2>>/tmp/.errlog # copy over new mirrorlist
    /bin/bash -c /opt/craccken-installer/post_install.sh &>>/tmp/.scriptlog
    run_command_in_mountpoint "/bin/bash -c /opt/craccken-installer/chrooted_post_install.sh" &>>/tmp/.scriptlog
    cp /tmp/.scriptlog ${MOUNTPOINT}/var/log/installer_ps_log 2>>/tmp/.errlog
    # Clean up installation
    rm -rf ${MOUNTPOINT}/vomi 2>>/tmp/.errlog
    rm -rf ${BYPASS} 2>>/tmp/.errlog
    rm -rf ${MOUNTPOINT}/source 2>>/tmp/.errlog
    rm -rf ${MOUNTPOINT}/src 2>>/tmp/.errlog
}

install_bootloader(){ # Install Bootloader
    check_mount
    run_command_in_mountpoint "PATH=/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/bin/core_perl" 2>/tmp/.errlog # Set the default PATH variable
    check_for_error
    if [[ $SYSTEM == "BIOS" ]]; then
        select_device
        dialog --backtitle "$BACKTITLE" --title " Grub-install " --infobox "\nPlease wait...\n\n" 0 0
        run_command_in_mountpoint "grub-install --target=i386-pc --recheck $DEVICE" 2>/tmp/.errlog
        run_command_in_mountpoint "grub-mkconfig -o /boot/grub/grub.cfg" 2>>/tmp/.errlog
        check_for_error
        if ( [[ $LVM -eq 1 ]] && [[ $LVM_SEP_BOOT -eq 0 ]] ) || [[ $LVM_SEP_BOOT -eq 2 ]]; then # if /boot is LVM (whether using a seperate /boot mount or not), amend grub
            sed -i "s/GRUB_PRELOAD_MODULES=\"\"/GRUB_PRELOAD_MODULES=\"lvm\"/g" ${MOUNTPOINT}/etc/default/grub
            run_command_in_mountpoint "grub-mkconfig -o /boot/grub/grub.cfg" 2>>/tmp/.errlog
            check_for_error
        fi # End if-else statement
    else
        [[ -z $(mount | grep /sys/firmware/efi/efivars) ]] && mount -t efivarfs efivarfs /sys/firmware/efi/efivars # Ensure again that efivarfs is mounted
        dialog --backtitle "$BACKTITLE" --title " Grub-install " --infobox "\nPlease wait...\n\n" 0 0
        run_command_in_mountpoint "grub-install --target=x86_64-efi --efi-directory=${UEFI_MOUNT} --bootloader-id=craccken_grub --recheck" 2>/tmp/.errlog
        run_command_in_mountpoint "grub-mkconfig -o /boot/grub/grub.cfg" 2>>/tmp/.errlog # Generate config file
        check_for_error
        dialog --backtitle "$BACKTITLE" --title " $_InstUefiBtTitle " --yesno "$_SetBootDefBody ${UEFI_MOUNT}/EFI/boot $_SetBootDefBody2" 0 0 # Ask if user wishes to set Grub as the default bootloader and act accordingly
        if [[ $? -eq 0 ]]; then
            run_command_in_mountpoint "mkdir ${UEFI_MOUNT}/EFI/boot" 2>/tmp/.errlog
            run_command_in_mountpoint "cp -r ${UEFI_MOUNT}/EFI/craccken_grub/grubx64.efi ${UEFI_MOUNT}/EFI/boot/bootx64.efi" 2>>/tmp/.errlog
            check_for_error
            dialog --backtitle "$BACKTITLE" --title " $_InstUefiBtTitle " --infobox "\nGrub $_SetDefDoneBody" 0 0
        fi
    fi
}

prep_menu(){ # Create a function
    [[ $SUB_MENU != "prep_menu" ]] && SUB_MENU="prep_menu" && HIGHLIGHT_SUB=0
    local PREP_MENU_OPT # Create local variable
    local prep_menu_options=( "Set_Desktop_Keyboard_Layout" "List_Devices_(optional)" "Partition_Disk" "Mount_Partitions" "Back" ) # Create local array 
    for index in $(seq 1 ${#prep_menu_options[@]}); do # Create for-loop with length of array
        PREP_MENU_OPT="$PREP_MENU_OPT ${index} ${prep_menu_options[$((index - 1))]}" # Set PREP_MENU_OPT with options
    done # End for-loop statement
    dialog --cursor-off-label --default-item $((HIGHLIGHT_SUB + 1)) --backtitle "$BACKTITLE" --title " Prepare Installation " --menu "$_PrepMenuBody" 0 0 5 \
        ${PREP_MENU_OPT} 2>${ANSWER}
    HIGHLIGHT_SUB=$(read_answer)
	case $(read_answer) in # Read answer from prep_menu
        "1") set_xkbmap ;;
        "2") show_devices ;;
        "3") umount_partitions
             select_device
             create_partitions ;;
        "4") mount_partitions ;;        
          *) main_menu ;;
    esac # End switch-case statement
    prep_menu  	
}

install_root_menu(){ # Base Installation
    [[ $SUB_MENU != "install_root_menu" ]] && SUB_MENU="install_root_menu" && HIGHLIGHT_SUB=0
    dialog --default-item $(( HIGHLIGHT_SUB + 1 )) --backtitle "$BACKTITLE" --title "$_InstBsMenuTitle" --menu "$_InstBseMenuBody" 0 0 4 \
        "1" "$_InstBse" \
        "2" "$_InstBootldr" \
        "3" "$_Back" 2>${ANSWER}	
    HIGHLIGHT_SUB=$(read_answer)
    case $(read_answer) in # Read answer from install_root_menu
        "1") install_root && run_mkinitcpio ;;
        "2") install_bootloader ;;
        *) main_menu ;;
    esac # End switch-case statement
    install_root_menu 	
}

config_base_menu(){ # Base Configuration
    run_command_in_mountpoint "PATH=/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/bin/core_perl" 2>/tmp/.errlog # Set the default PATH variable
    check_for_error
    [[ $SUB_MENU != "config_base_menu" ]] && SUB_MENU="config_base_menu" && HIGHLIGHT_SUB=0
    dialog --default-item $(( HIGHLIGHT_SUB + 1 )) --backtitle "$BACKTITLE" --title " $_ConfBseMenuTitle " --menu "$_ConfBseBody" 0 0 8 \
        "1" "$_ConfBseFstab" \
        "2" "$_ConfBseHost" \
        "3" "$_ConfBseSysLoc" \
        "4" "$_ConfBseTimeHC" \
        "5" "$_ConfUsrNew" \
        "6" "$_Back" 2>${ANSWER}	
	HIGHLIGHT_SUB=$(read_answer)
    case $(read_answer) in
        "1") generate_fstab ;;
        "2") set_hostname ;;
        "3") set_locale ;;        
        "4") set_timezone && set_hw_clock ;;
        "5") create_new_user ;;
        *) main_menu ;;
    esac
    config_base_menu
}

edit_configs(){ # Edit configs of installed system
	local FILE # Clear the file variables
    [[ $SUB_MENU != "edit_configs" ]] && SUB_MENU="edit_configs" && HIGHLIGHT_SUB=0
    dialog --default-item $((HIGHLIGHT_SUB + 1)) --backtitle "$BACKTITLE" --title " $_SeeConfOptTitle " --menu "$_SeeConfOptBody" 0 0 12 \
        "1" "/etc/locale.conf" \
        "2" "/etc/hostname" \
        "3" "/etc/hosts" \
        "4" "/etc/mkinitcpio.conf" \
        "5" "/etc/fstab" \
        "6" "/etc/default/grub" \
        "7" "/etc/pacman.conf" \
        "8" "$_Back" 2>${ANSWER}
	HIGHLIGHT_SUB=$(read_answer)
    case $(read_answer) in
        "1") [[ -e $MOUNTPOINT/etc/locale.conf ]] && FILE="${MOUNTPOINT}/etc/locale.conf" ;;
        "2") [[ -e $MOUNTPOINT/etc/hostname ]] && FILE="${MOUNTPOINT}/etc/hostname" ;;
        "3") [[ -e $MOUNTPOINT/etc/hosts ]] && FILE="${MOUNTPOINT}/etc/hosts" ;;
        "4") [[ -e $MOUNTPOINT/etc/mkinitcpio.conf ]] && FILE="${MOUNTPOINT}/etc/mkinitcpio.conf" ;;
        "5") [[ -e $MOUNTPOINT/etc/fstab ]] && FILE="${MOUNTPOINT}/etc/fstab" ;;
        "6") [[ -e $MOUNTPOINT/etc/default/grub ]] && FILE="${MOUNTPOINT}/etc/default/grub" ;;
        "7") [[ -e $MOUNTPOINT/etc/pacman.conf ]] && FILE="${MOUNTPOINT}/etc/pacman.conf" ;;
        *) main_menu ;;
    esac # End switch-case statement
	[[ $FILE != "" ]] && nvim $FILE || dialog --backtitle "$BACKTITLE" --title " $_ErrTitle " --msgbox "$_SeeConfErrBody" 0 0
	edit_configs
}

main_menu(){ # Create a function
    echo ""
    PS3="$(zsh -ic 'info_msg "Select option"') "
    select main_menu_answer in "Prepare Installation" "Install base" "Configure base" "Review configuration files" "Done" "Quit"; do
        case "${main_menu_answer}" in
            "Prepare Installation")
                prep_menu
                ;;
            "Install base")
                check_mount
                install_root_menu
                ;;
            "Configure base")
                check_mount
                check_base
                config_base_menu
                ;;
            "Review configuration files")
                check_mount
                check_base
                edit_configs
                ;;
            "Done")
                zsh -ic "warn_msg 'Now you need to reboot!'"
                umount_partitions && exit
                ;;
            *)
                ExitHandler # Call function to handle exit
                ;;
        esac # End switch-case statement
    done
}

read_answer(){
    cat $ANSWER
}

ExitHandler(){
    zsh -ic "ask_msg 'Close Installer? (y/n)'; read -q"
    [[ ! $? -eq 0 ]] && main_menu || umount_partitions && exit
}

# Execution
trap ExitHandler SIGINT
zsh -ic "need_root_user" || exit $?
source /opt/craccken-installer/english.trans # Source translation file for installer
# sed -i "s/#en_US.UTF-8/en_US.UTF-8/" /etc/locale.gen && locale-gen &>/dev/null # Generate the chosen locale
> /tmp/.errlog # Clear error log, just in case something is there from a previous use the installer.
while true; do
    main_menu      
done # End while-loop
